namespace PostgreSqlSchemaCompareSync.Core.Comparison.Metadata;

/// <summary>
/// Specialized extractor for table metadata
/// </summary>
public class TableMetadataExtractor(
    ILogger<TableMetadataExtractor> logger) : IMetadataExtractor, IObjectMetadataExtractor, IObjectValidator
{
    private readonly ILogger<TableMetadataExtractor> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

    public ObjectType ObjectType => ObjectType.Table;

    /// <summary>
    /// Extracts table metadata
    /// </summary>
    public async Task<IEnumerable<DatabaseObject>> ExtractAsync(
        NpgsqlConnection connection,
        string? schemaFilter,
        CancellationToken cancellationToken)
    {
        var tables = new List<DatabaseObject>();

        const string query = @"
            SELECT
                c.relname AS table_name,
                n.nspname AS table_schema,
                pg_total_relation_size(c.oid) AS size_bytes,
                obj_description(c.oid, 'pg_class') AS description,
                pg_get_userbyid(c.relowner) AS owner,
                (
                    SELECT format(
                        'CREATE TABLE %I.%I (\n%s\n);',
                        n.nspname,
                        c.relname,
                        string_agg(
                            format(
                                '    %I %s%s%s%s',
                                a.attname,
                                pg_catalog.format_type(a.atttypid, a.atttypmod),
                                CASE WHEN a.attnotnull THEN ' NOT NULL' ELSE '' END,
                                CASE WHEN ad.adbin IS NOT NULL THEN ' DEFAULT ' || pg_get_expr(ad.adbin, ad.adrelid) ELSE '' END,
                                CASE a.attidentity
                                    WHEN 'a' THEN ' GENERATED ALWAYS AS IDENTITY'
                                    WHEN 'd' THEN ' GENERATED BY DEFAULT AS IDENTITY'
                                    ELSE ''
                                END
                            ),
                            E',\n'
                            ORDER BY a.attnum
                        )
                    )
                    FROM pg_attribute a
                    LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
                    WHERE a.attrelid = c.oid
                      AND a.attnum > 0
                      AND NOT a.attisdropped
                ) AS create_ddl
            FROM pg_class c
            JOIN pg_namespace n ON n.oid = c.relnamespace
            WHERE c.relkind = 'r'
              AND (@schemaFilter IS NULL OR n.nspname = @schemaFilter)
              AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
            ORDER BY n.nspname, c.relname";

        using var command = new NpgsqlCommand(query, connection);
        command.Parameters.AddWithValue("@schemaFilter", schemaFilter ?? (object)DBNull.Value);

        using var reader = await command.ExecuteReaderAsync(cancellationToken);
        while (await reader.ReadAsync(cancellationToken))
        {
            var tableName = reader.GetString(0);
            var schemaName = reader.GetString(1);
            var definition = reader.IsDBNull(5) ? string.Empty : reader.GetString(5);

            if (string.IsNullOrWhiteSpace(definition))
            {
                definition = $"CREATE TABLE \"{schemaName}\".\"{tableName}\" ();";
            }

            tables.Add(new DatabaseObject
            {
                Name = tableName,
                Schema = schemaName,
                Type = ObjectType.Table,
                Database = connection.Database,
                SizeInBytes = reader.IsDBNull(2) ? null : reader.GetInt64(2),
                Definition = definition,
                Owner = reader.IsDBNull(4) ? string.Empty : reader.GetString(4),
                CreatedAt = DateTime.UtcNow
            });
        }

        return tables;
    }

    /// <summary>
    /// Extracts detailed table information including columns
    /// </summary>
    public async Task<DatabaseObjectDetails> ExtractDetailsAsync(
        NpgsqlConnection connection,
        string schema,
        string tableName,
        CancellationToken cancellationToken)
    {
        var details = new DatabaseObjectDetails
        {
            Name = tableName,
            Type = ObjectType.Table,
            Schema = schema,
            Database = connection.Database,
            CreatedAt = DateTime.UtcNow
        };

        await ExtractTableDetailsAsync(connection, details, cancellationToken);
        return details;
    }

    /// <summary>
    /// Validates table objects
    /// </summary>
    public async Task<ObjectValidationResult> ValidateAsync(
        NpgsqlConnection connection,
        DatabaseObject table,
        CancellationToken cancellationToken)
    {
        var result = new ObjectValidationResult
        {
            IsValid = true,
            Errors = [],
            Warnings = [],
            Metadata = []
        };

        try
        {
            _logger.LogDebug("Validating table {Schema}.{TableName}", table.Schema, table.Name);

            // Check if table exists and is accessible
            const string query = @"
                SELECT COUNT(*)
                FROM information_schema.tables t
                JOIN pg_class c ON c.relname = t.table_name
                JOIN pg_namespace n ON c.relnamespace = n.oid AND n.nspname = t.table_schema
                WHERE t.table_schema = @schema AND t.table_name = @tableName";

            using var command = new NpgsqlCommand(query, connection);
            command.Parameters.AddWithValue("@schema", table.Schema);
            command.Parameters.AddWithValue("@tableName", table.Name);

            var countResult = await command.ExecuteScalarAsync(cancellationToken);
            var count = countResult != null ? (long)countResult : 0;

            if (count == 0)
            {
                result.IsValid = false;
                result.Errors.Add("Table does not exist or is not accessible");
            }
            else
            {
                result.Metadata["TableExists"] = true;

                // Check for additional table issues
                const string advancedQuery = @"
                        SELECT
                            c.relhasindex AS has_indexes,
                            c.relhasrules AS has_rules,
                            c.relhastriggers AS has_triggers,
                            c.relhassubclass AS has_subclass,
                            CASE c.relkind
                                WHEN 'r' THEN 'regular table'
                                WHEN 'v' THEN 'view'
                                WHEN 'f' THEN 'foreign table'
                                WHEN 'p' THEN 'partitioned table'
                                ELSE 'other'
                            END AS table_kind,
                            pg_total_relation_size(c.oid) AS size_bytes,
                            COALESCE(c.reltuples, 0) AS estimated_rows
                        FROM pg_class c
                        JOIN pg_namespace n ON c.relnamespace = n.oid
                        WHERE n.nspname = @schema AND c.relname = @tableName";

                using var advCommand = new NpgsqlCommand(advancedQuery, connection);
                advCommand.Parameters.AddWithValue("@schema", table.Schema);
                advCommand.Parameters.AddWithValue("@tableName", table.Name);

                using var advReader = await advCommand.ExecuteReaderAsync(cancellationToken);
                if (await advReader.ReadAsync(cancellationToken))
                {
                    result.Metadata["HasIndexes"] = advReader.GetBoolean(0);
                    result.Metadata["HasRules"] = advReader.GetBoolean(1);
                    result.Metadata["HasTriggers"] = advReader.GetBoolean(2);
                    result.Metadata["HasSubclass"] = advReader.GetBoolean(3);
                    result.Metadata["TableKind"] = advReader.GetString(4);
                    result.Metadata["SizeBytes"] = advReader.GetInt64(5);
                    result.Metadata["EstimatedRows"] = advReader.GetFloat(6);

                    // Add warnings for potential issues
                    if (!advReader.GetBoolean(0))
                        result.Warnings.Add("Table has no indexes - may impact query performance");

                    if (advReader.GetBoolean(3))
                        result.Warnings.Add("Table has subclasses - inheritance may affect operations");
                }

                // Check for column consistency
                const string columnQuery = @"
                    SELECT COUNT(*) FROM information_schema.columns
                    WHERE table_schema = @schema AND table_name = @tableName";

                using var colCommand = new NpgsqlCommand(columnQuery, connection);
                colCommand.Parameters.AddWithValue("@schema", table.Schema);
                colCommand.Parameters.AddWithValue("@tableName", table.Name);

                var columnCountResult = await colCommand.ExecuteScalarAsync(cancellationToken);
                var columnCount = columnCountResult != null ? (long)columnCountResult : 0;
                result.Metadata["ColumnCount"] = columnCount;

                if (columnCount == 0)
                {
                    result.Warnings.Add("Table has no columns defined");
                }
            }

            result.Metadata["ValidationDate"] = DateTime.UtcNow;
            result.Metadata["ObjectType"] = table.Type.ToString();

            _logger.LogDebug("Validation completed for table {Schema}.{TableName}: Valid={IsValid}",
                table.Schema, table.Name, result.IsValid);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to validate table {Schema}.{TableName}", table.Schema, table.Name);

            result.IsValid = false;
            result.Errors.Add($"Validation error: {ex.Message}");
            return result;
        }
    }

    /// <summary>
    /// Extracts detailed table information including columns
    /// </summary>
    private async Task ExtractTableDetailsAsync(
        NpgsqlConnection connection,
        DatabaseObjectDetails details,
        CancellationToken cancellationToken)
    {
        // Get columns with enhanced information
        const string columnQuery = @"
            SELECT
                c.column_name,
                c.data_type,
                c.is_nullable,
                c.column_default,
                c.character_maximum_length,
                c.numeric_precision,
                c.numeric_scale,
                c.ordinal_position,
                CASE WHEN pk.column_name IS NOT NULL THEN 'PRIMARY KEY' ELSE '' END as column_key,
                c.domain_name,
                c.is_generated,
                c.generation_expression,
                c.is_identity,
                c.identity_start,
                c.identity_increment,
                c.identity_maximum,
                c.identity_minimum,
                c.identity_cycle,
                col_description(format('%I.%I', @schema, @tableName)::regclass, c.ordinal_position) as column_comment
            FROM information_schema.columns c
            LEFT JOIN information_schema.key_column_usage kcu ON kcu.column_name = c.column_name
                AND kcu.table_name = c.table_name AND kcu.table_schema = c.table_schema
            LEFT JOIN information_schema.table_constraints pk ON pk.constraint_name = kcu.constraint_name
                AND pk.table_name = kcu.table_name AND pk.table_schema = kcu.table_schema
                AND pk.constraint_type = 'PRIMARY KEY'
            WHERE c.table_schema = @schema AND c.table_name = @tableName
            ORDER BY c.ordinal_position";

        using var columnCommand = new NpgsqlCommand(columnQuery, connection);
        columnCommand.Parameters.AddWithValue("@schema", details.Schema);
        columnCommand.Parameters.AddWithValue("@tableName", details.Name);

        using var columnReader = await columnCommand.ExecuteReaderAsync(cancellationToken);
        while (await columnReader.ReadAsync(cancellationToken))
        {
            var columnKey = columnReader.IsDBNull(8) ? "" : columnReader.GetString(8);

            details.Columns.Add(new ColumnInfo
            {
                Name = columnReader.GetString(0),
                DataType = columnReader.GetString(1),
                IsNullable = columnReader.GetString(2) == "YES",
                DefaultValue = columnReader.IsDBNull(3) ? null : columnReader.GetString(3),
                MaxLength = columnReader.IsDBNull(4) ? null : (int?)columnReader.GetInt32(4),
                Precision = columnReader.IsDBNull(5) ? null : (int?)columnReader.GetInt32(5),
                Scale = columnReader.IsDBNull(6) ? null : (int?)columnReader.GetInt32(6),
                IsPrimaryKey = columnKey.Contains("PRIMARY KEY"),
                IsForeignKey = false, // Would need additional query to determine
                References = null // Would need additional query to determine
            });

            // Add column-specific metadata
            var columnName = columnReader.GetString(0);
            details.AdditionalInfo[$"Column_{columnName}_Position"] = columnReader.GetInt32(7);
            details.AdditionalInfo[$"Column_{columnName}_Domain"] = columnReader.IsDBNull(9) ? string.Empty : columnReader.GetString(9);
            details.AdditionalInfo[$"Column_{columnName}_IsGenerated"] = columnReader.IsDBNull(10) ? false : columnReader.GetString(10) == "ALWAYS";
            details.AdditionalInfo[$"Column_{columnName}_GenerationExpression"] = columnReader.IsDBNull(11) ? string.Empty : columnReader.GetString(11);
            details.AdditionalInfo[$"Column_{columnName}_IsIdentity"] = columnReader.IsDBNull(12) ? false : columnReader.GetString(12) == "YES";
            details.AdditionalInfo[$"Column_{columnName}_Comment"] = columnReader.IsDBNull(18) ? string.Empty : columnReader.GetString(18);
        }
    }
}